hibernate
	hibernate入门和基本操作
		web内容回顾
			javaee三层结构
				web层：struts2框架
				service层：spring框架
				dao层：hibernate框架
					对数据库进行crud操作（数据库增删改查）
			mvc思想
				m：模型
				v：视图
				c：控制器
		hibernate概述
			hibernate框架
				1.应用在javaee三层结构中dao层框架
				2.在dao层里面做对数据库crup操作，使用hibernate实现crup操作，hibernate底层代码就是jdbc，hibernate对jdbc进行封装，使用hibernate不需要写复杂的jdbc代码，也不用写sql语句实现
				3.hibernate开源轻量级框架
				4.hibernate版本
			orm思想
				hibernate使用orm思想对数据库进行crup操作
				在web阶段学习javabean，实体类
				orm：object relational mapping--对象关系映射
				--让实体类和数据库表进行一一对应关系
					让实体类首先和数据库表对应
					让实体类属性和表里面的字段对应
				--不需直接操作数据库表，而操作表对应实体类对象，从而实现操作数据库表
					jdbc代码
						加载驱动
						Class.forName("com.mysql.jdbc.Driver");
						创建链接
						Connection conn = DriverManager.getConnection(url,username.password);
						//对sql进行预编译工作
						String sql = "select * from user";
						PreparedStatment psmt = conn.prepareStatement(sql);
						//执行sql  查询sql
						ResultSet rs = pstm.executeQuery();
						//遍历结果集
						... ...
						//释放资源
						... ...
					orm思想代码
						public class User{
						private int uid;
						private String username;
						private String password;
						}
						create table t_user{
						uid int,
						username varchar(100),
						password varchar(100)
						}
						让类和表对应
						让类属性和表字段对应
						使用配置文件的方式实现上面的功能，后面就不用再操作表了，直接操作表对应的实体类对象就可以
						在hibernate中就将初始化类对象的方法等进行封装成Session类，在操作时只需要创建一个Session对象并调用其方法就可
		hibernate入门案例
			第一步：
				导入hibernate的jar包
					1.lib\required文件夹下所有jar包
					2.lib\jpa-metamodel-generator下仅有的一个jar包
					3.以下四个jar包
					log4j-1.2.16.jar
					mysql-connector-java-5.0.4-bin.jar
					slf4j-api-1.6.1.jar
					slf4j-log4j12-1.7.2.jar
			第二步：创建实体类
				使用hibernate时候，不需要自己手动创建表，hibernate会自动把表创建好
			第三步：配置实体类和数据库表一一对应关系（映射关系），使用配置文件实现
				1.创建xml格式的配置文件
				--映射配置文件名称和位置没有固定要求
				--在实际中，建议在实体类所在的包里面创建，实体类名称hbm.xml
				2.配置文件是xml格式，在配置文件中首先引入xml约束
				3.配置映射关系（重点）
					01.配置类和表对应：
						class标签：
							name属性：实体类全路径
							table属性：数据库表名
					02.配置实体类id和表id对应：hibernate要求实体类有一个属性唯一值，表有字段唯一值
						id标签
							name属性：实体类里面的id属性名称
							column属性：生成的表字段名
					03.可设置数据库表id增长策略
						generator标签：
							class属性：native--自动增长
					04.配置其他属性和表字段对应：直接在id标签下
						property标签：
							name属性：同id
							column属性：同id
							
							<class name="cn.itcast.entity.Customer" table="t_customer">
								<id name="cid" column="cid">
									<generator class="native"></generator>
								</id>
								<property name="custName" column="custName"></property>
								<property name="custLevel" column="custLevel"></property>
								<property name="custSource" column="custSource"></property>
								<property name="custPhone" column="custPhone"></property>
								<property name="custMobile" column="custMobile"></property>
							</class>
			第四步：创建hibernate核心配置文件
				1.核心配置文件格式xml，但是文件名称和位置是固定的
					位置：src下
					名称：hibernate.cfg.xml
				2.引入约束文件
				3.hibernate操作过程中，只会加载核心配置文件，其他配置文件不会加载
					第一部分：配置数据库信息（必须含有）
					第二部分：配置hibernate信息（可有可无）
					第三部分：把映射文件放到核心配置文件中（必须的）
			第五步：实现添加操作
				1.加载hibernate核心配置文件
				2.创建SessionFactory对象
				3.使用SessionFactory创建session对象
				4.开启事务
				5.写具体逻辑crup操作
				6.提交事务
				7.关闭资源
				效果：
					--是否生成表
					--表中是否有记录
		hibernate配置文件
			hibernate映射配置文件
				1.映射配置文件名称和位置没有固定要求
				2.映射配置文件中，标签name属性值是实体类相关内容
					--class标签name属性值实体类全路径
					--id标签和property标签name属性值 实体类中的属性名称
				3.id标签和property标签，column属性可以省略：不写默认和name属性值相同
				4.property标签type属性，设置生成表字段的类型，自动对应类型。
			hibernate核心配置文件
				1.配置写位要求
					<hibernate-configuration>
						<session-factory>
				2.配置三部分要求
					(1)数据库部分必须的
					(2)hibernate部分可选
					(3)映射文件必须的
				3.核心配置文件名称和位置固定的
					(1)位置：src下面
					(2)hibernate.cfg.xml
				4.接口、类的使用
		Configuration
							
		SessionFactory
							
		Session
							
		Transaction
							
	hibernate概念和api使用
							
	hibernate配置一对多和多对多
	hibernate查询操作
	第二天
		1.实体类的编写规则
			(1)实体类里面的属性都是私有的
							
			(2)私有属性使用公开的get和set方法
			(3)要求实体类有属性作为唯一值（一般使用id值）
			(4)实体类属性建议不使用基本数据类型，使用基本数据类型对用的包装类
				(1)八个基本数据类型对应的包装类
				(2)使用包装类可以实现特殊情况下的数据类型转换
			()
			()
			()
		2.hibernate主键生成策略
			(1)要求：实体类里面有一个属性作为唯一值，对应表主键，主键可以有不同生成策略
			(2)hibernate主键生成策略有很多值
				--native：根据底层数据库对自动生成表示符的能力来选择生成器，适合跨平台开发。
				--uuid：hibernate采用128位的uuid算法来生成标识符，其值被编码成一个长度为32位的十六进制字符串。如果使用uuid生成策略，实体类id属性值类型必须是字符串类型
							
							
		3.实体类操作
			(1)crud操作
				--添加操作
					User user = new User();
					user.setUsername("小李");
					user.setPassword("1414151");
					user.setAddress("北京");
					//调用session的save方法实现添加
					session.save(user);
				--添加二：使用save添加新对象，设置的uid不会按着表的现状添加，而是根据生成策略继续增加。。。。。。
					User user = new User();
					user.setUid(1);
					user.setUsername("ma;ma");
					user.setPassword("1656");
					user.setAddress("zhongguo");
					session.save(user);
				--根据id查询
					1.根据id查询，并返回对象
						User user = session.get(User.class, 2);
				--修改一：
					1.根据id查询，并返回对象
						User user = session.get(User.class, 2);
					2.给对象修改属性值
						user.setUsername("东方不败");
					3.使用session对象调用update方法把对象修改值更新至数据库属性值
					session.update(user);
					也可使用save或者saveOrUpdate方法
				--修改二：根据uid修改username时，使用update方法时，等于覆盖了uid为1的对象，只设置了username值，其他未设置
					User user = new User();
					user.setUid(1);
					user.setUsername("tom");
					session.update(user);
					
					
				--删除：
					先找到需要删除的对象，然后执行删除操作
					User user = session.get(User.class, 2);
					session.delete(user);
				--删除二
					User user1 = new User();
					user1.setUid(3);
					session.delete(user1);
					
			(2)实体类对象状态
				--瞬时态(添加对象时未设置id，没有给表里保存时)：对象里面没有id值，对象与session没有关联
										
				--持久态(查询操作时，从数据库查询并获取的对象)：对象里面有id值，对象与session已经关联
										
				--托管态(创建对象后，只使用getUid获取了id值的对象)：对象里面有id值，对象与session没有关联
				--根据实体类对象状态进行saveOrUpdate方法的使用
					1.添加
						//4-1.添加操作--在瞬时态时
						User user = new User();
						user.setUsername("小李子");
								user.setPassword("14141f51");
						user.setAddress("北京南");
						//在瞬时态时，调用session的saveOrUpdate方法实现添加
						session.saveOrUpdate(user);
					2.修改
						//4-2.修改操作--托管态
						User user = new User();
						user.setUid(4);
						user.setUsername("小李子");
						user.setPassword("14141f51");
						user.setAddress("北南");
						//在托管态时，调用session的saveOrUpdate方法实现修改
						session.saveOrUpdate(user);
					3.修改
						//4-3.修改操作
						User user = session.get(User.class, 4);
						user.setUsername("alsdfjalsdjflask");
						//在持久态时，调用session的saveOrUpdate方法实现修改
						session.saveOrUpdate(user);
		4.hibernate的一级缓存
			--什么是缓存
				数据存储到数据库里面，数据库本身是文件系统，使用流方式操作文件效率并不是很高.
					(1)把数据存到内存里面，不需要使用流方式，可以直接读取内存中的数据
					(2)把数据放到内存中，增加读取效率
			--hibernate框架中提供很多的优化方式，hibernate的缓存就是一个优化方式
			--hibernate缓存特点
				第一类  hibernate的一级缓存
					1.hibernate的一级缓存默认是打开的
					2.hibernate的一级缓存有使用范围：session对象的范围，session对象创建到关闭
					3.hibernate的一级缓存中，存储数据必须是持久态数据
							
				第二类  hibernate的二级缓存
					1.目前已经不使用了，使用redis替代了
					2.二级缓存默认不是打开的，需要配置
					3.二级缓存适用范围：是整个项目的范围，是sessionFactory（一个项目只有一个sessionFactory）范围
			--验证一级缓存的存在
				验证方式：
					1.首先根据uid=1查询，返回对象
					2.其次再根据uid=1查询，返回对象
				一级缓存执行过程
					//4-1.根据uid=4查询
					//执行了第一个get方法是否查询数据库，是否发送sql语句
					/*
					 * 第一步：查询一级缓存区，没有发现数据。
					 * 第二步：执行查询数据库语句，返回suer1对象(持久态对象)
					 * 第三步：把user1对象的数据保存在一级缓存区中
					 */
					User user1 = session.get(User.class, 4);
					System.out.println(user1);
					//4-2.再次根据uid=4查询
					//执行了第二个get方法是否查询数据库，是否发送sql语句
					/*
					 * 第一步：到一级缓存区中根据uid查询User对象的数据。
					 * 第二步：发现相同数据，重组数据，产生user2对象返回
					 */
					User user2 = session.get(User.class, 4);
					System.out.println(user2);
			hibernate一级缓存特性
				持久态自动更新数据库
					//4-1.根据id查询
					/*
					 * 第一步：查询一级缓存区，没有发现数据。
					 * 第二步：执行查询数据库语句，返回suer1对象(持久态对象)
					 * 第三步：把user1对象的数据保存在一级缓存区中和与之对应的快照区中
					 */
					User user = session.get(User.class,5);
					//4-2.设置返回对象值
					 * 修改user对象里面的值，修改持久态对象的值
					 * 同时修改一级缓存中的内容，但不会修改对应快照区的内容
					user.setUsername("星期六");
					//4-3.调用方法实现
					//session.update(user);
					//5.提交事务
					/*
					 * 提交事务时，进行一级缓存区与对应快照区的比较，
					 * 查看是否相同，如果不相同，则把一级缓存区的内容更新到数据库，
					 * 如果相同则不会进行修改
					 */
					tx.commit();
							
							
							
							
							
							
		5.hibernate的事务操作
			(1)事务相关概念
				--什么是事务
							
				--事务的特性
							
				--不考虑隔离性产生问题
					1.脏读
							
					2.不可重复读
							
					3.虚读
							
				--设置事务隔离级别
							
					1.mysql默认隔离级别repeatable read
							
			(2)事务代码规则写法
				SessionFactory sessionFactory = null;
				Session session = null;
				Transaction tx = null;
				try {
					//1.调用工具类
					sessionFactory = HibernateUtils.getSessionFactory();
					//2.获取session
					session = sessionFactory.openSession();
					//3.开启事务
					tx = session.beginTransaction();
					//4-1.根据id查询
					//User user = session.get(User.class,5);
					//4-2.设置返回对象值
					/*
					 * 修改user对象里面的值，修改持久态对象的值
					 * 同时修改一级缓存中的内容
					 */
					//user.setUsername("星期六");
					//4-3.调用方法实现
					//session.update(user);
					
					User user2 = new User();
					user2.setUid(2);
					user2.setUsername("张飞");
					user2.setPassword("556563");
					user2.setAddress("洛阳");
					session.save(user2);
					//5.提交事务
					/*
					 * 提交事务时，进行一级缓存区与对应快照区的比较，
					 * 查看是否相同，如果不相同，则把一级缓存区的内容更新到数据库，
					 * 如果相同则不会进行修改
					 */
					tx.commit();
					
						} catch (Exception e) {
					//6.回滚事务
					tx.rollback();
						}finally{
					//7.关闭资源
					session.close();
					sessionFactory.close();
						}
			(3)hibernate绑定session
				1.session类似于jdbc的connection，之前web阶段学过threadLocal
							
				2.帮实现与本地线程绑定session
							
				3.获取与本地线程session
					--在hibernate核心配置文件中配置
						1.配置session绑定本地线程
							<property name="hibernate.current_session_context_class">thread</property>
						2.提供返回与本地线程绑定的session方法
						public static Session getSessionobject(){
							return sessionFactory.getCurrentSession();
						}
				4.获取与本地线程绑定session时候，关闭session报错，不需要手动关闭session。
					--调用sessionFactory
							
		6.hibernate其他api（查询）
			(1)Query对象
				1.使用query对象，不需要写sql语句，而使用hql语句
					--hql；hibernate query language 提供查询语言，hql语言和普通sql语言很相似
					--hql和sql的区别
						1.使用sql操作表和表字段
						2.使用hql操作实体类和属性
				2.查询所有hql语句
					--form实体类的名称
				3.Query对象的使用
					--创建Query对象
					--调用query对象里面的方法得到结果
			(2)Criteria对象
				1.使用这个对象查询操作，使用这个对象不需要写语句，直接调用方法实现
				2.实现过程
					--创建Criteria对象
					--调用对象里面的方法得到结果
							
							
							
							
							
							
							
							
							
							
							
							
			(3)SQLQuery对象
							
	第三天：
		1、表与表之间的关系回顾
		2、一对多（客户和联系人，分类和商品，一个分类里有多个商品，一个商品只有一个分类）：在多的哪一方多创建一个字段，作为外键，指向少的那一方的主键（id）
			(1)一对多的映射配置
				第一步：导入jar包，创建客户和联系人的实体类
				第二步：让两个实体类之间相互表示
					(1)在客户实体类里面表示多个联系人：一个客户里面有多个联系人
					(2)在联系人实体类里面表示所属客户：一个联系人只能属于一个客户
				第三步：配置映射关系
					(1)一般一个实体类对应一个映射文件
					(2)把映射最基本配置完成
					(3)在映射文件中配置一对多的映射关系
						--在客户映射文件中表示所有联系人
							<property name="custMobile" column="custMobile"></property>
								<!-- 在映射文件中，表示所有联系人所属的客户 -->
								<!-- 使用set标签    name属性：在客户实体类里面表示联系人的set集合名称 -->
								<set name="setLinkMan">
									<!-- 一对多建表，有外键：hibernate机制，双向维护外键，在一和多哪一方都配置外键 -->
									<!-- column属性：外键名称，可任意名，建议有意义 -->
									<key column="clid"></key>
									<!-- 客户所有的联系人，class里面写联系人实体类的全路径 -->
									<one-to-many class="cn.itcast.entity.LinkMan"/>
							</set>
						--在联系人文件中表示所属的客户
							<!-- 表示联系人所属的客户 -->
							<!-- name属性：因为在联系人实体类使用customer对象表示 ，故是customer-->
							<!-- class属性：customer对象类的全路径 -->
							<!-- column属性：对应的外键名称 -->
							<many-to-one name=""></many-to-one>
				第四步：创建核心配置文件
						
			--一对多的级联操作
				级联操作：
					1.级联保存：添加一个客户，为这个客户添加多个联系人
					2.级联删除：删除一个客户，这个客户的所有联系人也删除
			(2)一对多的级联保存
				--基本写法：
					//1.添加一个客户，为这个客户添加一个联系人
					Customer customer = new Customer();
					customer.setCustName("百度");
					customer.setCustLevel("vip");
					customer.setCustSource("网络连接");
					customer.setCustPhone("17791654327");
					customer.setCustMobile("18292991419");
					
					LinkMan linkman = new LinkMan();
					linkman.setLkm_name("王林娜");
					linkman.setLkm_gender("女");
					linkman.setLkm_phone("15709203975");
					//2.在客户表示所有的联系人，在联系人表示客户，
					//建立客户对象和联系人对象的关系
					//2.1把联系人对象放到客户对象的set集合里面去
					customer.getSetLinkMan().add(linkman);
					//2.2把客户对象放到联系人里面去
					linkman.setCustomer(customer);
					//3.保存到数据库
					session.save(customer);
					session.save(linkman);
				--简化写法：
					第一步：在客户映射文件中进行配置
						<set name="setLinkMan" cascade="save-update">
					第二步：创建客户和联系人对象，把联系人放到客户中去，最终只需要保存客户就可以了
						//1.添加一个客户，为这个客户添加一个联系人
						Customer customer = new Customer();
						customer.setCustName("百度");
						customer.setCustLevel("普通客户");
						customer.setCustSource("网络连接");
						customer.setCustPhone("18929299927");
						customer.setCustMobile("1492959419");
						
						LinkMan linkman = new LinkMan();
						linkman.setLkm_name("向阳");
						linkman.setLkm_gender("女");
						linkman.setLkm_phone("155585548455");
						//2.建立客户对象和联系人对象的关系
						//把联系人对象放到客户对象的set集合里面去
						customer.getSetLinkMan().add(linkman);
						//3.保存到数据库
						session.save(customer);
			(3)一对多的级联删除：删除一个客户，并且把客户里面的所有联系人也删除
				第一步：在客户映射文件set标签进行配置
					<set name="setLinkMan" cascade="save-update,delete">
				第二步：在代码中直接根据id查询并删除客户就可以
					//1.根据id查询客户对象
					Customer customer = session.get(Customer.class, 2);
					//2.调用方法删除
					session.delete(customer);
			一对多的级联修改：修改联系人所属的客户
				//1.根据id查询联系人，再根据id查询百度的客户
				LinkMan linkman = session.get(LinkMan.class, 1);
				Customer customer = session.get(Customer.class, 2);
				//2.设置持久态对象值
				//2.1把联系人放到客户里面
				customer.getSetLinkMan().add(linkman);
				//2.2把客户放到联系人里面
				linkman.setCustomer(customer);
			(4)inverse属性
				hibernate中双向维护外键，在客户和联系人里面都需要维护外键，修改客户时修改一次外键，修改联系人时也修改外键，造成效率低下问题。
				解决方式：让其中一方不维护外键，即一对多里面，让“一”方放弃维护外键。
				在放弃关系维护映射文件中进行配置，在set标签上使用inverse属性实现
				<!-- inverse属性：默认false即不放弃维护外键的机会，true即放弃维护外键的机会 -->
				<set name="setLinkMan" cascade="save-update,delete" inverse="true">
		3、多对多（用户和角色，一个用户可有多个角色，一个角色也可以有多个用户。订单和商品，一个订单可有多个商品，一个商品可存在多个订单。）：创建第三张表，至少有两个字段，指向两个表的主键，多对多的对应关系一一列举在此表中。
			(1)多对多的映射配置：例--用户和角色
				第一步：创建实体类，用户和角色
						
				第二步：让两个实体类之间相互表示
					(1)一个用户里面表示所有的角色，使用set集合
					
					(2)一个角色有多个用户，使用set集合
						
				第三步：配置映射关系
					(1)基本配置
					
					(2)配置多对多的关系
						1、在用户里面表示所有的角色，使用set标签
						<!-- name属性：角色set集合名 -->
						<!-- table属性：第三张表名 -->
						<set name="setRole" table="user_role">
							<!-- key标签里面的配置 -->
							<!-- column属性：配置当前映射文件在第三张表的外键名称 -->
							<key column="userid"></key>
							<!-- class属性：角色实体类全路径 -->
							<!-- column属性：角色在第三张表的外键名称 -->
							<many-to-many class="cn.itcast.manytomany.Role" column="roleid"></many-to-many>
						</set>
						2、在角色里面表示所有的用户，使用set标签
						<!-- name属性：用户set集合名 -->
						<!-- table属性：第三张表名 -->
						<set name="setUser" table="user_role">
							<!-- key标签里面的配置 -->
							<!-- column属性：配置当前映射文件在第三张表的外键名称 -->
							<key column="roleid"></key>
							<!-- class属性：用户实体类全路径 -->
							<!-- column属性：用户在第三张表的外键名称 -->
							<many-to-many class="cn.itcast.manytomany.User" column="userid"></many-to-many>
						</set>
				第四步：在核心配置文件中引入映射文件
					<mapping resource="cn/itcast/manytomany/User.hbm.xml"/>
					<mapping resource="cn/itcast/manytomany/Role.hbm.xml"/>
			(2)多对多的级联保存
				根据用户保存角色
					第一步：在用户配置文件中set标签进行配置cascade属性值设置为save-update
						<set name="setRole" table="user_role" cascade="save-update">
					第二步：创建用户和角色对象，把角色放到用户里面，最终保存用户就可以了。
						--1.添加两个用户，为两个用户添加三个角色
						--2.建立关系，把角色添加到用户里面
						--3.保存用户
						
			(3)多对多的级联删除
				第一步：在set标签进行配置
					<set name="setRole" table="user_role" cascade="save-update,delete">
				第二步：通过id查找用户或者角色并执行删除
						
			(4)维护第三张表关系
				1、让某个用户有某个角色
					第一步：根据id查询用户和角色
						
					第二步：把角色放到用户里，把角色对象放进用户set集合
						
				2、让某个用户失去某个角色
					第一步：根据id查询用户和角色
						
					第二步：从用户里面把角色移除，从用户set集合里面移除需要移除的角色
	第四天
		1.hibernate的查询方式
			(1)对象导航查询
				根据id查询某个客户，在出巡这个客户里面所有的联系人。
			(2)OID查询
				根据id查询某一条记录，返回对象
					调用session里面的get方法实现查询
					Customer customer = session.get(Customer.class, 1);
			(3)hql查询：hibernate query language，hibernate提供的一种查询语言，hql语言和普通sql很相似，区别是普通sql操作数据库表和字段，hql操作实体类和属性
				--创建Query对象，写hql语句实现查询
				--调用query对象里面的方法得到结果
				
			(4)QBC查询
				Criteria对象
			(5)本地sql查询
				SQLQuery对象，使用普通sql实现查询
							
							
							
							
							
							
							
							
							
		2.对象导航查询：查询某个客户所有联系人的过程
			//1.要查询cid=1的客户，再查询这个客户的所有联系人
			Customer customer = session.get(Customer.class, 1);
			//2.再查询这个客户的所有联系人
			Set<LinkMan> linkman = customer.getSetLinkMan();
							
		3.hql查询：
			(1)查询所有：from 实体类名
				//1.要查询cid=1的客户，再查询这个客户的所有联系人
				Query query = session.createQuery("from Customer");
				//2.调用方法得到结果
				List<Customer> list = query.list();
				for (Customer customer : list) {
					System.out.println(customer.getCid()+"::"+customer.getCustName());
				}
			(2)条件查询：from 实体类名 where 属性名称=?
				//1.创建Query对象
				//SELETE * FROM t_customer WHERE cid=? AND custName=?
				Query query = session.createQuery("from Customer where cid=? and custName=?");
				//2.设置条件值
				//向？里面设置值
				//setParameter方法两个参数
				//第一个参数：int类型是第？位置，？位置从0开始
				//第二个参数：具体的参数值
				//设置第一个？的值
				query.setParameter(0, 3);
				//设置第二个？的值
				query.setParameter(1, "百度");
				//3.调用list方法得到结果
				List<Customer> list = query.list();
							
							
				//1.创建Query对象
				//SELETE * FROM t_customer WHERE cid=? AND custName=?
				Query query = session.createQuery("from Customer where custName like ?");
				//2.设置条件值
				//向？里面设置值
				//setParameter方法两个参数
				//第一个参数：int类型是第？位置，？位置从0开始
				//第二个参数：具体的参数值
				//设置？的值
				query.setParameter(0, "%谷%");
				//3.调用list方法得到结果
				List<Customer> list = query.list();
			(3)排序查询：form 实体类名称 order by 实体类属性名称 asc/desc
				//1.创建Query对象
				Query query = session.createQuery("from Customer order by cid asc");
				//2.调用list方法得到结果
				List<Customer> list = query.list();
							
			(4)分页查询：sql实现：SELETE * FROM t_customer LIMIT 0,3(从0开始，每页显示三条数据)
				--在hql操作中，在语句里面不能写limit，hibernate的Query对象封装两个方法实现分页操作
				//1.创建Query对象
				//查询所有数据
				Query query = session.createQuery("from Customer ");
				//2.设置分页数据参数
				//2.1设置开始位置
				query.setFirstResult(0);
				//2.2设置每页记录数据个数
				query.setMaxResults(3);
				//3.调用方法得到结果
				List<Customer> list = query.list();
							
			(5)投影查询：查询的不是所有，是部分字段的值（部分列），SELETE 字段名 FROM 表名
				hql语句：select 实体类属性名1，实体类属性名2 from 实体类名
				//1.创建Query对象
				//查询所有数据
				Query query = session.createQuery("from custName from Customer ");
				//2.调用方法得到结果
				List<Object> list = query.list();
							
							
							
			(6)聚集函数使用
				count:SELETE COUNT(*) FROM t_customer
				select count(*) from 实体类名称
				//1.创建Query对象
				//查询所有数据
				Query query = session.createQuery("select custName from Customer ");
				//2.调用方法得到结果
				//Query里面有方法，调用直接返回对向形式
				Object obj = query.uniqueResult();
				//			int count = (int) obj;// 不能直接强转，出现ClassCastException错误，需要先转成long类型，在调用intValue方法实现int类型转换
				Long lobj = (Long) obj;
				int count = lobj.intValue();
				System.out.println(count);
							
		4.qbc查询：使用Criteria对象的方法实现查询等，操作实体类和属性
			(1)查询所有
				//1.创建Criteria对象
				//查询所有数据
				Criteria criteria = session.createCriteria(Customer.class);
				//2.调用方法得到结果
				List<Customer> list = criteria.list();
			(2)条件查询
				//1.创建Criteria对象，查询数据
				Criteria criteria = session.createCriteria(Customer.class);
				//2.使用Criteria对象里面的方法设置条件值
				//首先使用add方法，表示设置条件值
				//类似于cid=？
				criteria.add(Restrictions.eq("cid", 2));
				criteria.add(Restrictions.eq("custName", "谷歌"));
				//3.调用方法得到结果
				List<Customer> list = criteria.list();
			(3)排序查询
				//1.创建Criteria对象，查询数据
				Criteria criteria = session.createCriteria(Customer.class);
				//2.使用Criteria对象里面的方法设置对那个属性进行排序，设置排序规则
				criteria.addOrder(Order.asc("cid"));
				//3.调用方法得到结果
				List<Customer> list = criteria.list();
			(4)分页查询
				//1.创建Criteria对象，查询数据
				Criteria criteria = session.createCriteria(Customer.class);
				//2.使用Criteria对象里面的方法设置分页数据
				//2.1设置开始位置
				criteria.setFirstResult(0);
				//2.2设置每页记录数
				criteria.setMaxResults(3);
				//3.调用方法得到结果
				List<Customer> list = criteria.list();
			(5)统计查询
				//1.创建Criteria对象，查询数据
				Criteria criteria = session.createCriteria(Customer.class);
				//2.使用Criteria对象里面的方法设置分页数据
				criteria.setProjection(Projections.rowCount());
				//3.调用方法得到结果
				Object obj = criteria.uniqueResult();
				Long lobj = (Long) obj;
				int count = lobj.intValue();
			(6)离线查询
				--servlet调用service，service调用dao
					(1)在dao里面对数据库crud操作
					(2)在dao里面使用hibernate框架，使用hibernate框架的时候，调用session里面的方法实现功能
										
		5.hql多表查询
			(1)mysql多表查询回顾
				--内连接查询：
					方式一：SELECT * FROM t_customer c,t_linkman l WHERE c.cid=l.clid
					方式二：SELECT * FROM t_customer c INNER JOIN t_linkman l ON c.cid=l.clid
				--左外连接查询：
					SELECT * FROM t_customer c LEFT OUTER JOIN t_linkman l ON c.cid=l.clid
				--右外连接查询：
					SELECT * FROM t_customer c RIGHT OUTER JOIN t_linkman l ON c.cid=l.clid
			(2)hql多表查询----以客户和联系人为例
				--内连接：hql语句：from 客户实体类 客户实体类别名 inner join 客户实体类别名.放联系人的set集合
					//1.创建Query对象，查询数据
					Query query = session.createQuery("from Customer c inner join c.setLinkMan");
					//2.调用方法得到结果(数组)
					List<Customer> list = query.list();
				--左外连接：hql语句：from 客户实体类 客户实体类别名 left outer join  客户实体类别名.放联系人的set集合
					//1.创建Query对象，查询数据
					Query query = session.createQuery("from Customer c left outer join c.setLinkMan");
					//2.调用方法得到结果(数组)
					List<Customer> list = query.list();
				--右外连接：hql语句：from 客户实体类 客户实体类别名 right outer join  客户实体类别名.放联系人的set集合
				--迫切内连接：hql语句：from 客户实体类 客户实体类别名 inner join fetch  客户实体类别名.放联系人的set集合
					//1.创建Query对象，查询数据
					Query query = session.createQuery("from Customer c inner join fetch c.setLinkMan");
					//2.调用方法得到结果(对象)
					List<Customer> list = query.list();
				--迫切左外连接：hql语句：from 客户实体类 客户实体类别名 left outer join fetch  客户实体类别名.放联系人的set集合
		6.hibernate的检索策略：
			(1)概念
				第一类：立即查询--根据id查询，调用get方法，一调用get方法，马上发送语句查询数据库。
						
						
				第二类：延迟查询--根据id查询，调用load方法不会马上发送语句查询数据库，直到得到对象里面的值得时候才会发送语句查询数据库
						
						
			(2)具体操作
																																																																																																																																					

struts2
	第一天：struts2入门
		struts2概述
			1.struts2框架应用javaee三层结构中web层框架
			2.struts2框架在struts1和webwork基础之上发展卡里的全新框架
			3.struts2解决问题
			4.struts2版本
			5.web层常见框架
				--struts2框架
				--springMVC框架
		struts2入门案例
			第一步：导入jar包
				新建web工程
				下载的struts2包解压出来的lib文件夹下所需jar包
			第二步：创建action类
				在Java Resources下面的src下创建action类
				每次访问action时都会先默认执行execute方法
			第三步：配置action类的访问路径
				1.创建struts2--核心配置文件
				--核心配置文件的名称（struts.xml）和位置（src下面）是固定的
				2.引入dtd约束文件
				<!DOCTYPE struts PUBLIC  
				    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"  
				    "http://struts.apache.org/dtds/struts-2.0.dtd">  
				<struts>
				    <package name="hellodemo" extends="struts-default" namespace="/">
				    <!-- name属性：最终访问名称   class属性：action类的绝对路径-->
				    <action name="hello" class="cn.itcast.action.HelloAction">
				    <!-- 配置方法的返回值到不同页面 -->
				    <result name="ok">/hello.jsp</result>
				    </action>
				    </package>
				</struts>
			第四步：配置过滤器
				
		struts2底层执行过程
			1.网络请求
			    发送网络请求
			2.过滤器
			    过滤器实现功能（
			    --在服务器启动时就创建，创建过滤器时执行init方法--看源码）
			    ----在init方法中主要加载配置文件
			    ------主要包含自己创建的配置文件和struts2自带的配置文件
			    --------struts.xml
			    --------web.xml
			3.获取请求路径
			    得到路径里面所要找的请求页面名称--hello值
			4.到src下面找到struts.xml文件，使用dom4j解析xml文件得到文件中的内容
			5.在xml文件中去寻找action标签中的name属性值
			    并和请求的页面名称是否匹配
			    匹配上之后，再寻找action标签的class属性值（action类的全路径）
			    使用反射实现功能
					（Class clazz = Class.forName("action类的全路径")）
					得到名称是execute的方法
					Method m = clazz.getMethod("execute")
					方法执行，并返回值
					Object obj = m.invoke();
			6.得到action类中excute方法的返回值
			    在struts.xml文件中，找到action标签里面的result标签name属性值
			    并和获取到返回值进行匹配是否相同
			    相同跳转至hello页面
		struts2相关配置
			struts2的核心配置文件：
				1.配置文件的名称和位置是固定的
				2.配置文件中的三个标签和属性
					(1)package标签：类似于代码的包，区别不同的action，要配置action必须写package标签
						--name属性：和功能本身没有关系，可任意定义，一个配置文件中可以有多个package标签，但name属性值不能相同。
						--extents属性：属性值是固定的，struts-default，写了这个属性之后，在package里面配置的类就具有了action标签所特有的功能
						--namespace属性：属性值和action标签里面的name属性值构成访问路径，可不写此属性，不写时默认“/”
					(2)action标签：action标签配置action类访问路径
						--name属性：属性值和package标签里面的namespace属性值构成访问路径，一个配置文件中可以有多个action标签，但name属性值不能相同。
						--class属性：action类的完全路径（用于反射）
						--method属性：action默认执行excute方法，但在action类里面可以写其他方法，使用method（属性值是什么方法名就执行什么方法）进行配置选择让什么方法执行
					(3)result标签：根据action类的方法返回值，配置到不同的路径里面去（跳转不同页面）
						--name属性：和方法返回值相同，配置方法返回值到页面
						--type属性：配置如何到路径中去（转发或者重定向），默认转发操作
					(4)constant标签：在struts.xml中配置，修改默认常量值（01.在src下面创建struts.properties文件进行修改。02.在web.xml中进行配置修改）
						--name属性：常量名
						--value属性：常量值
						重点：struts.i18n.encoding = UTF-8
							1.表单提交数据到action里面，在action可以获取表单提交数据
							2.表单提交数据中有中文，有乱码问题，解决：
								--post提交方式--直接设置编码格式
								--get提交做编码转换
								在action获取表单通过post方式提交中文，中文乱码问题已经帮助解决，不需要再进行处理。get方式需要自己转换
						分模块开发：
							--个人单独写配置文件，把配置文件引入到核心配置文件中去。
								--使用到include标签：属性file=“其他配置文件的路径之间用“/”不用“.””
						action编写方式（三种）
							--创建普通类，不继承任何类，不实现任何接口
							--创建类，实现Action接口（勿导错包）
							--创建类，继承ActionSupport类（常用）
								
								
								
		struts2的action创建
		struts2的action方法访问
	第二天：struts2数据操作
	1.结果页面的配置：
		(1)全局结果页面
			result标签配置action方法返回值到不同的页面路径里面去
			创建两个action，执行默认的方法execute方法，让两个action的方法都返回success，返回success之后，配置到同一个页面
				(1)如果多个action，方法里面返回值相同，最终页面也相同，适用于全局结果页面配置
					<package name="demo1" extends="struts-defalut" namespace="/">
					<action name="book" class="cn.itcast.action.BookAction">
					<result name="success">/hello.jsp</result>
					</action>
					<action name="orders" class="cn.itcast.action.OrdersAction">
					<result name="success">/hello.jsp</result>
					</action>
					</package>
				(2)在package标签里面配置
					<package name="demo1" extends="struts-defalut" namespace="/">
					<global-results>
					<result name="success">/hello.jsp</result>
					</global-results>
					<action name="book" class="cn.itcast.action.BookAction">
					<!-- <result name="success">/hello.jsp</result> -->
					</action>
					<action name="orders" class="cn.itcast.action.OrdersAction">
					<!-- <result name="success">/hello.jsp</result> -->
					</action>
					</package>
		(2)局部结果页面
			配置全局结果页面，也配置局部结果页面，最终以局部结果页面为准
		(3)result标签的type属性
			--type属性：配置如何到路径中去（转发或者重定向），默认转发操作
			--type属性值(到页面中去)
				默认值：dispatcher  做转发操作
				做重定向操作：redirect  访问地址由hello.action变成world.jsp
			--type属性值(到action中去)
				chain：转发到action  访问路径没有改变，页面改变
				redirectAction：重定向到action
					使用了redirectAction参数之后，result标签内容就是所要跳转的action标签name属性值  访问路径和页面都改变
					<action name="book" class="cn.itcast.action.BookAction">
					<result name="success" type="redirectAction">orders</result>
					</action>
					<action name="orders" class="cn.itcast.action.OrdersAction">
					<result name="success">/orders.jsp</result>
					</action>
	2.在action获取表单提交数据
		--提交表单到action，但是action中没有request对象，不能直接使用request对象
		(1)使用ActionContext类获取
			--使用getParameters()方法，返回一个包含HttpServletRequest参数信息，需要ActionContext对象来实现（不是静态方法）
			--使用static ActionContext getContext()方法获取ActionContext对象
			具体实现：
				1.创建表单，提交表单到action里面
				2.在action里面使用ActionContext获取数据（上面方法）
		(2)使用ServletActionContext类获取
			--使用ServletActionContext获取request对象（getRequest()）方法
			--调用request里面的方法得到结果（getParameter()方法）
		(3)使用接口注入方式获取
			--实现ServletRequestAware接口，实现setServletRequest方法在里面将传入的request赋值给成员变量(通过this调用)
			--在execute方法里面使用getParameter方法
		--在action中操作三个域对象
			request域
				1.得到域对象：HttpServletRequest request = ServletActionContext.getRequest();
				2.给域对象放入值:request.setAttribute("req","reqValue");
			session域
				1.得到session域：HttpSession session = request.getSession();
				2.调用session里面的方法添加数据:session.setAttribute("sess","sessValue");
			ServletContext域
				1.得到域对象：ServletContext context = ServletActionContext.getServletContext();
				2.添加数据：context.setAttribute("contextName","contextValue");
				
				
				
	3.struts2提供获取表单数据方式:三种
		(1)属性封装（能将表单获取到的值放到属性中去，不能封装到实体类对象中去）
			--定义成员变量(变量名称和表单输入项的name属性值相同)
			--生成变量的set和get方法
		(2)模型驱动封装（重点）：可以直接把表单数据封装到实体类对象中去**前提条件：表单输入项name属性值必须和实体类属性名称相同
			--action类实现ModelDriven接口(implements ModelDriven<实体类名>)
			--实现接口里面的getModel方法，把创建的对象返回
			--在action类里面创建实体类对象(--手动创建实体类对象，在getModel方法里面返回创建的实体类对象)
		注意事项：在一个action中，获取表单数据可以属性封装，也可以使用模型封装，但不能同时使用属性封装和模型封装封装同一个表单数据，如果同时使用，则只执行模型封装
		(3)表达式封装：
			--在action类里面声明一个实体类
			--生成实体类变量的set和get方法
			--在表单输入项的name属性值里面写表达式形式(user.username:在action类里面通过get方法获取实体类对象user，用实体类对象“.”username调用set方法将属性值设置进实体类对象中去)
	4.struts2获取数据封装到集合中
		(1)封装到list集合
			--在action类里面声明成员变量List<实体类> list
			--生成list变量的set和get方法
			--在表单输入项里面写表达式(list[0].username:list集合的第一个对象“.”username将属性值设置进实体类对象中)
		(2)封装到map集合
			--声明成员变量Map<key值：String类型,实体类：User> map
			--生成get和set方法
			--在表单输入项的name属性值里面写入表达式：map['haha'].username
	5.扩展-表达式封装和模型驱动比较
		相同点：都可以把数据封装到实体类里面去
		不同点：
			--使用模型驱动只能把数据封装到一个实体类对象里面，在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面
			--使用表达式封装可以把数据封装到不同的实体类对象里面
							
	6.案例-添加客户功能
	
	第三天：struts2值栈
	1.ognl概述
		(1)EL表达式在jsp中获取域对象里面的值
		(2)ognl是一种表达式，这个表达式功能更加强大
			--在struts2里面操作值栈数据
			--一般把ognl在struts2操作：和struts2标签一起使用操作值栈
		(3)ognl不是struts2的一部分，是单独的项目，可单独运行，只是经常和struts2一起使用
			使用ognl时首先导入jar包，struts2提供jar包
		()
	2.ognl入门案例
		(1)使用ognl+struts2标签实现计算字符串长度：在java代码中，调用字符串.length();
		(2)使用struts2标签
			--使用struts2标签时，首先在jsp中引入标签库(<%@ taglib uri="/struts-Type" content="s" %>)
			--使用struts2标签实现操作(<s:property value="'haha'.length()"/>)--value属性值：ognl表达式
	3.什么是值栈
		(1)servlet和action区别
			(1)Servlet：默认在第一次访问的时候创建，创建一次，单实例对象
			(2)Action：访问时候创建，每次访问action时候，都会创建action对象，创建多次，多实例对象
			web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到，域对象在一定范围内，存值和取值
			在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值
				--在action里面吧数据放到值栈里面，在页面中获取到值栈数据
		
		(2)值栈存储位置
			(1)每次访问action的时候，都会创建action对象
			(2)在每个action对象里面都会有一个值栈对象
	4.如何获取值栈对象
		(1)使用ActionContext类里面的方法获取值栈对象(常用方法)
			--获取ActionContext类对象
			--调用getValueStack()方法获取值栈对象
		(2)每个action对象中只有一个值栈对象
		()
					
					
					
	5.值栈内部结构：两部分
		第一部分：root，结构是list集合，一般操作都是root里面的数据
		第二部分：context，结构是map集合
			key固定        value
			request        request对象引用
			session        HttpSession对象引用
			application    ServletContext对象引用
			parameters     传递相关参数
			attr           三个域对象，向三个域对象放值，名称都相同
					
					
	6.向值栈放数据
		(1)s：debug标签：常看值栈结构和存储值
			--访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个标签
			--action对象里面有值栈对象
			--值栈对象里面有action的引用--为了取值方便
		**向值栈中放数据方式：
			第一种：获取值栈对象，调用值栈对象里面的set方法
				1.获取值栈对象：
				ActionContext context = ActionContext.getContext();
				ValueStack stack = context.getValueStack();
				2.调用set方法
				stack.setAttribute("username","itcasttheheima");
			第二种：获取值栈对象，调用值栈对象里面的push方法
				1.获取值栈对象：
				ActionContext context = ActionContext.getContext();
				ValueStack stack = context.getValueStack();
				2.调用push方法
				stack.push("itcasttheheima");
			第三种：在action定义变量，生成变量的get方法：节约空间，值直接存储在action对象里面
				1.定义变量
				2.生成变量的get方法
				3.在执行方法里面向变量直接赋值
						
		(2)向值栈放字符串
						
		(3)向值栈放对象
						
		(4)向值栈放list集合
						
	7.从值栈获取数据：使用struts2+ognl表达式获取值栈数据《<s:propertv value="ognl表达式"/>
		(1)从值栈获取字符串
						
		(2)从值栈获取对象
						
		(3)从值栈获取list集合
						
		--s：iterator标签使用
						
	8.EL表达式获取值栈数据
					
	9.ognl表达式#、%使用
					
		()
	第四天：struts2拦截器
	1.拦截器概述
		(1)struts2是框架，封装了很多的功能，struts2里面封装的功能都是在拦截器里面
		(2)struts2里面封装了很多的功能，有很多拦截器，不是每次这些拦截器都执行，每次只执行默认的拦截器
		(3)struts2里面默认拦截器的位置：struts2-core-2.5.10.jar---->struts-default.xml----><interceptor-stack name="defaultStack">标签下
		(4)拦截器在什么时候执行：action对象创建之后，调用action默认方法之前执行
					
					
	2.拦截器底层原理
		(1)aop思想
			aop是面向切面编程，有基本功能，扩展功能，不通过修改源代码方式在源代码运行过程中扩展功能
		(2)责任链模式
			--java中有很多的设计模式，责任链模式只是其中一种
			--责任链模式和过滤链模式相似
				--过滤链模式：一个请求可有多个过滤器进行过滤，每个过滤器只有放行才能到下个过滤器
				责任链模式：要执行多个操作，有添加、修改、删除。首先执行添加操作，添加操作执行完毕后，做类似于放行的操作，再执行修改操作，修改操作完成后再做类似放行操作，再执行删除操作。
				
		(3)aop思想和责任链模式如何应用到拦截器里面？
			在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action没有直接调用拦截器的方法，使用配置文件方式进行操作
			在执行拦截器时候，执行很多拦截器，这个过程使用责任链模式，完成后执行action里面的方法
		(4)查看源码
			--执行action：execute.executeAction(request,response,mapping)
			--创建action对象，使用动态代理方式产生一个代理action对象
			--使用动态代理对象调用action的execute方法
			--执行很多拦截器，遍历执行
	3.过滤器和拦截器的区别
		(1)过滤器和拦截器的区别
			--过滤器：过滤器理论上可以过滤任意内容，例如html、jsp、servlet、图片路径等
			--拦截器：拦截器只可以拦截action
		(2)servlet和action区别
			--servlet：默认第一次访问时候创建，创建一次，单实例对象
			--action：每次访问时都创建对象，创建多次，多实例对象
	4.自定义登录拦截器
		需求：在struts2中有很多的拦截器，这些拦截器都是struts2封装的功能，但在实际开发中，struts2里面的拦截器不能满足开发需求，这时需要自定义拦截器来满足开发需求。
		拦截器结构：
			(1)查看拦截器源代码，仿照源代码继承AbstractInterceptor类来自定义拦截器
				--继承AbstractInterceptor
				--AbstractInterceptor实现Interceptor接口
				--Interceptor接口中有三个方法
					----void init();  初始化操作
					----void destroy();  销毁操作
					----String intercept(ActionInvocation invocation);  拦截逻辑操作
			(2)开发中建议使用另一种方式，写类继承MethodFilterInterceptor类实现，可实现让action里面某个方法不进行拦截。
			(3)让拦截器和action有关系：不是在action里面调用拦截器的方法，通过配置文件实现
			(4)添加登录拦截器功能
				--判断是否登录：判断session里面是否有名称username的值
				--拦截器实现过程
				第一步：创建类，继承MethodFilterInterceptor类
				第二步：重写MethodFilterInterceptor
				类里面的方法，写拦截器逻辑
					拦截器逻辑：
						--判断session里面是否有名称是username的值(获取session对象通过session对象获取username值，进行判断，有session值，说明是登录状态则执行放行操作invoke()方法)
						--不是登录状态，不执行action方法，到result标签里面找到名称是login的值，再到配置路径所示页面去
				第三步：配置action和拦截器关系(注册拦截器)
					(1)在要拦截的action标签所在的package标签里面声明拦截器:
					<interceptors>
						<interceptor name="loginintercept" class="cn.itcast.interceptor.LoginInterceptor"></interceptor>
					</interceptors>
					(2)使用拦截器：在action标签里面使用自定义标签:
					<interceptor-ref name="loginintercept"></interceptor-ref>
					(3)struts2里面会执行许多默认拦截器，但是如果在action里面配置了自定义的拦截器，系统就不会执行默认的拦截器了。
					需要把默认拦截器手动执行一次
					<interceptor-ref name="defaultStack"></interceptor-ref>
					(4)配置拦截器对action里面所有的方法都进行拦截
						(1)在action里面有login的登录方法，这个方法不需要拦截，但已然拦截，需要让action里面的login方法运行
						(2)让login方法不进行拦截：直接在自定义拦截器使用时通过配置方式让action里面的某些方法不进行拦截
						<interceptor-ref name="loginintercept">
							<param name="excludeMethods">login</param>
						</interceptor-ref>
	5.struts2标签库
		(1)s:property :和ognl表达式在jsp页面中获取值栈数据
		(2)s:iterator :获取值栈list集合数据 ，表示list集合
		(3)s:debug标签 ：查看值栈结构和数据
													
	6.struts2表单标签
Spring
	第一天：spring概念和ioc入门（ioc操作xml配置文件）
		1.spring概念：
			(1)spring是开源的轻量级框架
			(2)spring核心两部分
				--aop：面向切面编程，扩展功能不需要修改源代码实现
				--ioc：控制反转，比如有一个类，在类里面有方法（不是静态方法），调用类里面的方法，需要new一个对象调用方法，而控制反转就是创建对象这一步骤不是通过new，而是交给spring配置创建类对象
			(3)spring一站式框架
				--spring在javaee三层架构中，每一层都提供不同的解决技术
					----web层：springMVC
					----service层：spring的ioc
					----dao层：spring的jdbcTemplate
			(4)spring版本
		2.spring的入门
			(1)ioc底层原理
				--xml配置文件
				--dom4j解决xml
				--工厂设计模式
				--反射
				public class UserService{
				
				}
				public class UserServlet{
					//得到UserService的对象
					//原始：new创建对象
					//UserFactory.getService();
				}
				第一步：创建xml配置文件，配置要创建的对象类：
					<bean id="userService" class="cn.itcast.UserService">
				第二步：创建工厂类，使用dom4j解析配置文件（得到配置文件中的类名）+反射（通过类名和反射原理实现创建对象）：
					public class UserFactory{
						//创建返回UserService对象的方法
						public static UserService getService(){
							//1.使用dom4j解析xml文件，根据id值uerService得到id值对应的class属性值即要创建的对象类的全路径
							String classValue = "class属性值"；
							//2.使用反射创建类对象
							Class clazz = Class.forName(classValue);
							//创建类对象
							UserService service = clazz.newInstance();
							return service;
						}
					}
										
										
			(2)ioc入门案例
				第一步：导入jar包
										
				第二步：创建类，在类里面创建方法
										
				第三步：创建spring配置文件，配置创建类
					(1)spring核心配置文件名称和位置不是固定的，建议放到src下面，名称建议applicationContext.xml
					(2)引入schema约束
					(3)配置对象创建：id属性值实体类名小写，class属性值是实体类全路径
						<bean id="user" class="cn.itcast.ioc.User"></bean>
										
				第四步：写代码测试
										
			(3)解决配置文件没有提示
										
		3.spring的bean管理（xml配置文件）
						
			(1)bean实例化三种方式
				--使用无参构造方法创建（重点）
					<bean id="user" class="cn.itcast.ioc.User"></bean>
					注意：如果类里面没有无参构造，则会出现异常
									
									
				--使用静态工厂创建
									
				--使用实例工厂创建
									
			(2)bean标签常用属性
				--id属性：一个名称，用于使用时匹配此名称，得到配置的对象，属性值不能包含特殊符号
				--class属性：创建对象所在类的全路径
				--name属性：功能和id属性相同，但是可以包含特殊符号
				--scope属性：设置对象的整个范围
					----singleton：默认值，单例的，只创建一个对象
					----prototype：多例的
					----request：创建对象把对象放到request域里面去
					----session：创建对象把对象放到session域里面去
					globalSession：创建对象把对象放到globalSession里面
										
			(3)属性注入方式介绍：创建对象时，向类里面属性设置值
				(1)有参构造
					public class User {
						private String name;
						public User(String name){
							this.name = name;
						}
					}
					User user = new User("lucy");
				(2)属性的set方法
					public class User {
						private String name;
						public void setName(String name){
							this.name = name;
						} 
					}
					User user = new User();
					user.setName("abck");
				(3)接口注入
					public interface Dao{
						public void delete(String name);
					}
					public classDaoImpl implements Dao{
						private String name;
						public void delete(String name){
							this.name = name;
						}
					}
			(4)spring注入属性（有参构造和set方法）
				--有参构造方法实现属性注入
					<!-- 使用有参构造注入属性 -->
					<!-- <bean id="demo" class="cn.itcast.property.PropertyDemo1"> -->
						<!-- 使用有参构造注入 -->
						<!-- name属性值：有参构造属性名称        value属性值：有参构造属性设置的值 -->
						<!-- <constructor-arg name="username" value="王林娜是个猪"></constructor-arg>
					</bean> -->
				--set方法实现属性注入
					<!-- 使用set方法注入属性 -->
					<bean id="book" class="cn.itcast.property.Book">
						<!-- 注入属性值 -->
						<property name="bookname" value="王林娜是个猪猪"></property>
					</bean>
			(5)spring注入对象类型属性（重点）
				创建service类和dao类，在service得到dao类对象
					第一步：在service类中定义一个dao类型属性
										
					第二步：生成dao类属性的set方法
										
					第三步：在配置文件中，配置实现注入属性值
						<!-- 注入对象类型属性 -->
						<!-- 1.配置service和dao对象 -->
						<bean id="userDao" class="cn.itcast.ioc.UserDao"></bean>
						<bean id="userService" class="cn.itcast.ioc.UserService">
							<!-- 2.在service里面注入dao对象，name属性值：service类里面属性名称 ，ref属性值：dao配置bean标签中id属性值,表示将创建的userDao类对象注入到service中-->
							<property name="userDao" ref="userDao"></property>
						</bean>
										
			(6)p名称空间注入
				<!-- p：pname(对象的属性名称)="设置的属性值" -->
				<!-- <bean id="person" class="cn.itcast.property.Person" p:pname="你好"></bean> -->
			(7)spring注入复杂数据
					<!-- 注入复杂类型属性值 -->
					<bean id="person" class="cn.itcast.property.Person">
						<!-- 数组 -->
						<property name="arrs">
							<list>
								<value>王</value>
								<value>林</value>
								<value>娜</value>
							</list>
						</property>
						<!-- list -->
						<property name="list">
							<list>
								<value>笑啊</value>
								<value>小马</value>
								<value>小于</value>
							</list>
						</property>
						<!-- map -->
						<property name="map">
							<map>
								<entry key="aa" value="ll"></entry>
								<entry key="bb" value="gg"></entry>
								<entry key="cc" value="hh"></entry>
							</map>
						</property>
						<!-- properties -->
						<property name="properties">
							<props>
								<prop key="driverclass">com.mysql.jdbc.Driver</prop>
								<prop key="username">root</prop>
							</props>
						</property>
					</bean>
		4.ioc和di区别
			--ioc：控制反转，把对象创建交给spring进行配置
			--di：依赖注入，向类里面的属性设置值
			--关系：依赖注入不能单独存在，需要在ioc基础之上完成操作
		5.spring整合web项目原理：加载spring核心配置文件，创建对象，功能实现了，但是效率很低。解决方法：把配置文件和创建对象的过程在服务器启动时候完成
			实现原理：在服务器启动的时候，为每个项目创建一个ServletContext对象。在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建。使用监听器监听到ServletContext对象创建时候，加载spring配置文件，把配置文件配置的对象创建。把创建出来的对象放到ServletContext域对象里面（setAttribute方法）。获取对象的时候，到ServletContext域得到（getAttribute方法）
			(1)ServletContext对象
												
			(2)监听器
												
	第二天：spring的ioc操作（注解）和aop概念
		1.spring的bean管理（注解）
			(1)使用注解创建对象
				在类上面写@Component(value="user") 实现注解创建对象（默认是单实例，也可设置多实例，在类原有注解方式下面加@Scope(value="prototype")表示多实例）
			(2)使用注解注入属性：创建service类，创建dao类，在service里面的到dao对象
				--创建service类和dao类，并使用注解实现创建对象
				--在service类中写dao类的属性，并在属性上面使用注解实现属性值得注入（两种方式）
			(3)xml和注解方式混合使用
							
		2.AOP
			(1)aop概述
				--面向切面编程，扩展功能不修改源代码实现
				aop采取横向抽取机制，取代了传统纵向继承体系重复性代码
			(2)aop底层原理
				--提出问题
				public class User {
					//添加用户的方法
					public void add(){
						//添加逻辑
						
						//修改源代码，实现添加日志逻辑
					}
				}
				//扩展功能：
				//添加数据之后，添加日志功能
				//添加之后，记录在什么时间添加那个用户
				
				--纵向抽取机制解决
				public class BaseUser{
					//创建添加日志的方法
					public void writelog(){
						//添加日志逻辑
					}
				}
				public class User extends BaseUser{
					public void add(){
						//添加用户逻辑
						//功能扩展，添加日志功能
						//调用父类的方法实现添加日志功能
						super.writelog();
					}
				}
			(3)aop操作相关术语
				--连接点（Joinpoint）：类中哪些方法可以被增强，这些方法就称为连接点
				--切入点（Pointcut）：在类中可以有多个方法被增强，实际被增强的方法即切入点
				--通知/增强（Advice）：增强的逻辑，即称为增强或者通知
					----前置通知：在方法之前执行
					----后置通知：在方法之后执行
					----异常通知：方法出现异常
					----最终通知：在后置通知之后执行
					----环绕通知：方法之前和之后都执行
				--切面（Aspect）：把增强应用到具体的方法（切入点）上面，此过程称为切面
		3.spring的aop操作（基于aspectj的xml方式）
			在spring里面进行aop操作，使用aspectj实现
				
			使用aspectj实现aop的两种方式
				基于aspectj的xml配置
				基于aspectj的注释方式
			aop操作准备
				导入相关jar包
				创建spring核心配置文件，导入aop约束
											
								
								
		4.log4j介绍
													
													
		5.spring整合web项目演示
													
													
													
													
													
													
													
													
													
	第三天：jdbcTemplate和spring管理事务
		1.基于aspectj的注释aop操作
													
		2.spring的jdbcTemplate操作
													
		3.spring配置连接池
			(1)配置c3p0连接池
			(2)service和dao注入操作
							
		4.spring事务管理
			(1)事务概念
			(2)spring进行事务管理api
			(3)spring进行事务配置（声明式）
				--基于xml配置文件
				--基于注释方式
													
													
													
													
													
													
													
													
	第四天：ssh框架整合开发